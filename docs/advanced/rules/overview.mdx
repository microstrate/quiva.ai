---
title: "Overview"
description: "Evaluate business logic, calculate values, and make decisions using declarative rules"
---

## What is the Rules Step?

The Rules step evaluates business logic using a declarative rule engine. Instead of writing code, you define **facts** (your data) and **rules** (how to process it), and the engine automatically calculates outcomes.

<Card title="Think of it as..." icon="lightbulb">
  A spreadsheet formula system on steroids - where you define rules once and they automatically evaluate based on your data, handling complex logic like nested conditions, array processing, and dynamic calculations.
</Card>

## When to Use the Rules Step

<CardGroup cols={2}>
  <Card title="Pricing & Discounts" icon="tags">
    Calculate dynamic pricing, volume discounts, promotional offers
  </Card>
  <Card title="Eligibility Checks" icon="user-check">
    Determine qualifications, access levels, approval workflows
  </Card>
  <Card title="Data Validation" icon="shield-check">
    Enforce business constraints, validate forms, check data quality
  </Card>
  <Card title="Conditional Routing" icon="arrow-right-arrow-left">
    Route tickets, prioritize tasks, assign based on criteria
  </Card>
</CardGroup>

## How It Works

The Rules step takes two inputs:

<Steps>
  <Step title="Facts">
    A flat JSON object containing your data. Keys are what you reference with `@fact:`, values are either static data or [variable mapping](/advanced/variable-mapping/overview) expressions like `"$.previous_step.property"`
  </Step>
  <Step title="Rules">
    A JSON object defining the logic - what to calculate or decide based on the facts
  </Step>
  <Step title="Outcomes">
    The Rules step evaluates all rules and returns a flat object with outcomes for each rule
  </Step>
</Steps>

### Quick Example

Here's a simple rule that calculates if an order qualifies for free shipping:

**Facts (Input Data):**
```json
{
  "orderTotal.value": 75,
  "isPremiumMember.value": false
}
```

**Rules (Logic):**
```json
{
  "qualifiesForFreeShipping.value": {
    "operator": "or",
    "input": [
      {
        "operator": ">=",
        "input": ["@fact:orderTotal.value", 50]
      },
      {
        "operator": "=",
        "input": ["@fact:isPremiumMember.value", true]
      }
    ]
  }
}
```

**Output:**
```json
{
  "qualifiesForFreeShipping.value": true
}
```

## Key Capabilities

<AccordionGroup>
  <Accordion title="Mathematical Operations" icon="calculator">
    Perform calculations with add, subtract, multiply, divide, round, and advanced math functions
  </Accordion>
  
  <Accordion title="Conditional Logic" icon="code-branch">
    Build complex if-then-else logic with comparison operators and boolean operations
  </Accordion>
  
  <Accordion title="String Manipulation" icon="text">
    Concatenate, format, search, and transform text data
  </Accordion>
  
  <Accordion title="Array Processing" icon="list">
    Filter, sort, sum, and transform arrays of data with wildcard support
  </Accordion>
  
  <Accordion title="Date Operations" icon="calendar">
    Calculate date differences, add/subtract time periods, format dates
  </Accordion>
  
  <Accordion title="Lookups & Mapping" icon="table">
    Map values, perform lookups, create dynamic option lists
  </Accordion>
  
  <Accordion title="Dynamic Visibility" icon="eye">
    Control form field visibility based on other values
  </Accordion>
  
  <Accordion title="Validation Rules" icon="shield-check">
    Enforce business constraints and data quality requirements
  </Accordion>
</AccordionGroup>

## Real-World Example: E-commerce Pricing

Here's how an online store uses Rules to calculate dynamic pricing with discounts:

<CodeGroup>
```json Facts
{
  "cartItems.value": [
    { "price": 29.99, "quantity": 2 },
    { "price": 49.99, "quantity": 1 }
  ],
  "customerTier.value": "gold"
}
```

```json Rules
{
  "prices.value": {
    "operator": "jPath",
    "input": ["@fact:cartItems.value", "$[*].price"]
  },
  "orderTotal.value": {
    "operator": "+",
    "input": "@fact:prices.value"
  },
  "tierDiscount.value": {
    "operator": "map",
    "input": [
      "@fact:customerTier.value",
      {
        "bronze": 0,
        "silver": 0.05,
        "gold": 0.10,
        "platinum": 0.15
      }
    ]
  },
  "volumeDiscount.value": [
    {
      "condition": {
        "operator": ">=",
        "input": ["@fact:orderTotal.value", 100]
      },
      "outcome": 0.05
    },
    {
      "outcome": 0
    }
  ],
  "totalDiscount.value": {
    "operator": "max",
    "input": [
      "@fact:tierDiscount.value",
      "@fact:volumeDiscount.value"
    ]
  },
  "discountAmount.value": {
    "operator": "*",
    "input": [
      "@fact:orderTotal.value",
      "@fact:totalDiscount.value"
    ]
  },
  "finalPrice.value": {
    "operator": "-",
    "input": [
      "@fact:orderTotal.value",
      "@fact:discountAmount.value"
    ]
  }
}
```

```json Output
{
  "orderTotal.value": 109.97,
  "tierDiscount.value": 0.10,
  "volumeDiscount.value": 0.05,
  "totalDiscount.value": 0.10,
  "discountAmount.value": 10.997,
  "finalPrice.value": 98.973
}
```
</CodeGroup>

<Note>
  This example calculates cart total using `jPath` to extract prices from the array, applies the better of tier discount or volume discount, and computes the final price. Notice how rules reference each other using `@fact:ruleName.property` - the `.value` suffix is just part of the unique rule name. Learn more about [variable mapping](/advanced/variable-mapping/overview) to see how to pull data from previous steps.
</Note>

## Rule Formats

Rules can be written in two formats:

### Simple Format
Direct calculation without conditions:
```json
"ruleName.value": {
  "operator": "operatorName",
  "input": [param1, param2]
}
```

### Conditional Format
Array of condition/outcome pairs, evaluated top to bottom:
```json
"ruleName.value": [
  {
    "condition": {
      "operator": "operatorName",
      "input": [...]
    },
    "outcome": value
  },
  {
    "outcome": defaultValue
  }
]
```

## Common Use Cases

<CardGroup cols={2}>
  <Card title="E-commerce" icon="cart-shopping">
    Dynamic pricing, shipping calculations, inventory checks, promotional eligibility
  </Card>
  
  <Card title="CRM & Sales" icon="user-tie">
    Lead scoring, qualification criteria, territory assignment, commission calculations
  </Card>
  
  <Card title="Customer Support" icon="headset">
    Ticket routing, priority scoring, SLA calculations, escalation rules
  </Card>
  
  <Card title="Marketing" icon="bullhorn">
    Campaign eligibility, audience segmentation, A/B test assignment, personalization rules
  </Card>
  
  <Card title="Financial Services" icon="dollar-sign">
    Transaction validation, risk scoring, approval workflows, fee calculations
  </Card>
  
  <Card title="Healthcare" icon="heart-pulse">
    Patient eligibility, risk assessment, appointment scheduling, treatment pathways
  </Card>
</CardGroup>

## What's Next?

<CardGroup cols={2}>
  <Card title="Getting Started" icon="rocket" href="/flows/steps/rules/getting-started">
    Build your first rule in 5 minutes with a step-by-step tutorial
  </Card>
  <Card title="Core Concepts" icon="book" href="/flows/steps/rules/core-concepts">
    Deep dive into facts, rules, operators, and how data flows through the system
  </Card>
  <Card title="Operations Reference" icon="list-check" href="/flows/steps/rules/operations">
    Complete list of all available operators organized by category
  </Card>
  <Card title="Rule Patterns" icon="puzzle-piece" href="/flows/steps/rules/patterns">
    Common patterns and best practices with copy-paste examples
  </Card>
  <Card title="Examples Library" icon="code" href="/flows/steps/rules/examples">
    Real-world use cases with complete facts and rules
  </Card>
  <Card title="Technical Reference" icon="brackets-curly" href="/flows/steps/rules/api-reference">
    Input/output schemas and advanced technical details
  </Card>
</CardGroup>

## Quick Tips

<Tip>
  **Start Simple:** Begin with basic calculations and comparisons before building complex multi-condition logic
</Tip>

<Tip>
  **Test Often:** Use the Flow tester to test your rules with different input values
</Tip>

<Tip>
  **Reference Outputs:** Rules can reference the outcomes of other rules using `@fact:ruleName.property` - the property name (like `.value`) is just part of the unique rule name
</Tip>

<Tip>
  **Multiple Outcomes:** You can create multiple calculations from the same data by using different property names: `orderTotal.value`, `orderTotal.formatted`, `orderTotal.withTax`
</Tip>

<Warning>
  **Outcome Order Matters:** Within a single rule, outcomes are evaluated top to bottom - the first matching condition wins. However, the order of rules within your rules object doesn't matter; rules can reference each other's outcomes regardless of position.
</Warning>

<Info>
**Need Help?** Visit our [Help Center](https://microstrate.io/help.html) or join the [Community](/community) for support.
</Info>